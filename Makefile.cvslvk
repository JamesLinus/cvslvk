# The include-makefile for CVS-LVK projects.


override CL_HELPER := $(CL_DIR)/cvslvk


# $(CL_DEFAULT_GOAL) - what to make when "make" is run with no parameters
# Defaults to "all".

ifndef CL_DEFAULT_GOAL
CL_DEFAULT_GOAL = all
endif

default_goal: $(CL_DEFAULT_GOAL)


# $(ALWAYS) macro - a rule that should be applied even if file exists
#   ( usage:   xxx : $(ALWAYS) )
# This one is at the beginning because it is widely used below.

ALWAYS = /file/that/never/exists

$(ALWAYS):

# INTERNAL_LIBRARY is a special case of LIBRARY, that is used by the current
# module only. Static library will not be installed, and for shared library
# CNAME will not be installed
# We need to process it BEFORE command check
ifdef INTERNAL_LIBRARY
LIBRARY = $(INTERNAL_LIBRARY)
endif


# If no command is given, stop immidiatly
ifeq ($(EXECUTABLE)$(LIBRARY)$(SUBDIRS),)
override CL_TMP := $(shell $(CL_HELPER) error cvslvk: cannot determine mode. Please set EXECUTABLE, LIBRARY or SUBDIRS)
endif


# Are we going to do anything in the current directory ?
# If no, then most of the settings may be omitted
ifneq ($(EXECUTABLE)$(LIBRARY),)
CL_LOCALWORK = 1
endif


# Variable check subsystem
# Do this BEFORE the vars are used

# $(CL_VARS) lists variables to check.
# Either just names or name:val1|...|valN

# Check some system settings
ifneq ($(CL_COMP),)
override CL_VARS += CL_COMP:gcc|suncc
endif
ifneq ($(CL_LTYPE),)
override CL_VARS += CL_LTYPE:shared|static
endif
ifneq ($(filter create_wi update_wi,$(MAKECMDGOALS)),)
override CL_VARS += CL_MODULE
endif
ifneq ($(filter install,$(MAKECMDGOALS)),)
override CL_VARS += CL_PREFIX
endif

# The huge expression does the following:
#   for each CL_VARS entry result is: var=value [value1 ... valueN] --
override CL_CHECK_VARS_COMMAND = override CL_TMP := $(shell $(CL_HELPER) check_vars $(foreach d,$(CL_VARS),$(filter-out :%,$(subst :, :,$(d)))=$($(filter-out :%,$(subst :, :,$(d)))) $(subst |, ,$(filter-out $(filter-out :%,$(subst :, :,$(d))), $(subst :, ,$(d)))) --))
# The actual check (kills make on errors)
ifneq ($(CL_VARS),)
$(CL_CHECK_VARS_COMMAND)
endif

# Now clean CL_VARS.
# WI rules may add some additional vars to check.
# Then they may define new CL_VARS and use $(CL_CHECK_VARS_COMMAND)
override CL_VARS :=


# Architecture and OS are those we are using
# These are detected automatically using 'uname', but since 'uname' output
# is os- and architecture-dependent, we use a wrapper in $(CL_HELPER)
# Currently supported: solaris and linux, on x86 and sparc

override CL_ARCH := $(shell $(CL_HELPER) get_arch)
override CL_OS := $(shell $(CL_HELPER) get_os)


# Compiler defaults to GCC. Sun CC may be still used, if $(CL_COMP)=suncc
# $(CL_COMP) should be 'gcc' or 'suncc'

# Find out what WIs we will use.
# Required compiler setting may also go from here:
#   first parameter of "$(CL_HELPER) process_wi" is "need" or "compute",
#     "need" means that compiler is the build parameter anyway,
#     "compute" means that WI processing should find out whether it is needed 
#   second parameter of "$(CL_HELPER) process_wi" is "gcc" or "suncc" or "any"
#     "gcc" and "suncc" means that exacltly this compiler should be used
#     "any" means that WI processing should choose (it will try to use gcc
#     if possible)

ifdef CL_COMP
CL_COMP_TMP := $(CL_COMP)
else
CL_COMP_TMP := any
endif

ifdef CL_PARAM_COMP
CL_COMP_PARAM_TMP := need
else
CL_COMP_PARAM_TMP := compute
endif

# Don't do anythong more if we need only to show WI logic
# ('$(CL_HELPER) show_wi' will kill make)
ifeq ($(MAKECMDGOALS),show_wi)
override CL_TMP := $(shell $(CL_HELPER) show_wi $(CL_COMP_PARAM_TMP) $(CL_COMP_TMP) $(CL_USE_MODULES))
endif

# We want "make clean" and "make cleanall" to work even when WIs are not available
# So we process this case separately.
ifneq ($(filter clean cleanall,$(MAKECMDGOALS)),)
override CL_TMP := $(shell $(CL_HELPER) process_wi in_clean $(CL_COMP_PARAM_TMP) $(CL_COMP_TMP) $(CL_USE_MODULES))
else
override CL_TMP := $(shell $(CL_HELPER) process_wi $(CL_COMP_PARAM_TMP) $(CL_COMP_TMP) $(CL_USE_MODULES))
endif

ifeq ($(filter gcc,$(CL_TMP)),gcc)
override CL_PARAM_COMP := 1
override CL_COMP := gcc
endif
ifeq ($(filter suncc,$(CL_TMP)),suncc)
override CL_PARAM_COMP := 1
override CL_COMP := suncc
endif
ifeq ($(filter any,$(CL_TMP)),any)
ifndef CL_COMP
CL_COMP = gcc
endif
endif
override CL_WI_LIST := $(filter-out gcc suncc any,$(CL_TMP))


# Set C and C++ compilers

ifeq ($(CL_COMP),gcc)
override CC = gcc
override CXX = g++
endif
ifeq ($(CL_COMP),suncc)
override CC = cc
override CXX = CC
endif


# Set linker. If all user sources are .c files, linker will default to $(CC)
# Otherwise, it will default to $(CXX)

override CL_TMP := $(filter-out %.c, $(SOURCES))
ifeq ($(CL_TMP),)
override LD := $(CC)
else
override LD := $(CXX)
endif


# $(CL_LTYPE) defaults to 'shared' for gcc, 'static' for suncc
# Building shared libraries with suncc is not yet supported
# (suncc seems to have problems with static constructors in shared libs)

ifndef CL_LTYPE
ifeq ($(CL_COMP),gcc)
CL_LTYPE = shared
endif
ifeq ($(CL_COMP),suncc)
CL_LTYPE = static
endif
endif

ifeq ($(CL_COMP)-$(CL_LTYPE),suncc-shared)
override CL_TMP := $(shell $(CL_HELPER) error Building shared libraries with suncc is not yet supported)
endif


# Build parameters.
# All generated files will be placed into a subdir
#
# The combination of variables that are used to find out build parameters
# is the following.
# Always CL_ARCH, CL_OS are used, together with optimization and
# debugging flags.
#
# CL_COMP is used if CL_PARAM_COMP is defined, or if we are building
# a c++ library, or if we use a module that has CL_COMP in params
# (latter was checked above and now the result is in CL_PARAM_COMP)
#
# CL_LTYPE is used, if CL_PARAM_LTYPE is defined, or if we are building
# a library
#
# CL_OTHERP is used if defined

override CL_DIR_PARAMS := $(CL_ARCH)-$(CL_OS)

ifndef CL_PARAM_COMP
ifdef LIBRARY
ifeq ($(LD),$(CXX))
CL_PARAM_COMP = 1
endif
endif
endif
ifdef CL_PARAM_COMP
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_COMP)
endif

ifdef LIBRARY
CL_PARAM_LTYPE = 1
endif
ifdef CL_PARAM_LTYPE
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_LTYPE)
endif

ifdef CL_OTHERP
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_OTHERP)
endif

ifdef CL_OPTIMIZE
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-optimized
else
ifndef CL_NDEBUG
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-debug
endif
endif

# Now $(CL_DIR_PARAMS) is the parameter string

# Since WI logic don't work on 'make clean' (because we want 'make clean' to
# work even when there are WI errors), $(CL_BD) may be set incorrectly.
# When CL_PARAM_COMP is not set, comp will be not in $(CL_BD), but it *may*
# be in the real build birectory name.
# In this case we will rm -f all three options (without comp, with gcc and
# with suncc. Hopefully this is correct.

ifeq ($(MAKECMDGOALS),clean)
override CL_BD := $(shell $(CL_HELPER) get_bd_for_clean $(CL_DIR_PARAMS) $(CL_COMP))
else
ifeq ($(MAKECMDGOALS),cleanall)
override CL_BD := NONE
else
override CL_BD := $(CL_DIR_PARAMS)
ifdef CL_LOCALWORK
# Create the build directory and remove symlinks to other BDs
override CL_TMP := $(shell mkdir -p $(CL_BD); touch $(CL_BD)/CVSLVK_BUILD_DIR; $(CL_HELPER) remove_other_bd_links $(CL_BD))
endif
endif
endif


# Since some include files may be generated, we want to add $(CL_BD) to
# include search path. -I. is needed because without it, includes are searched
# in -I's only

ifdef CL_LOCALWORK
override INCLUDES += -I. -I$(CL_BD)
endif


# Compiler flags for debugging and optimizing
# By default, everything is built with debug information
# If CL_NDEBUG is set, everything will be built with no debug information
# If CL_OPTIMIZE is set, everything will be built with optimizations AND
# without debug information (optimization + gebug information is useless)
# For debugging with gcc, $(CL_GCC_DEBUG) is used, defaults to -g
# For debugging with suncc, $(CL_SUNCC_DEBUG) is used, defaults to -g
# For optimizing with gcc, $(CL_GCC_OPTIMIZE) is used, defaults to -O2
# For optimizing with suncc, $(CL_SUNCC_OPTIMIZE) is used, defaults to -O

override CFLAGS = -c
override CXXFLAGS = -c

# Handle sun CC's templates database
ifeq ($(CL_COMP),suncc)
override CXXFLAGS += -ptr$(CL_BD)
ifeq ($(LD),CC)
override LDFLAGS += -ptr$(CL_BD)
endif
endif

ifndef CL_GCC_DEBUG
CL_GCC_DEBUG = -g
endif
ifndef CL_SUNCC_DEBUG
CL_SUNCC_DEBUG = -g
endif

ifndef CL_NDEBUG
ifndef CL_OPTIMIZE
ifeq ($(CL_COMP),gcc)
override CFLAGS += $(CL_GCC_DEBUG)
override CXXFLAGS += $(CL_GCC_DEBUG)
endif
ifeq ($(CL_COMP),suncc)
override CFLAGS += $(CL_SUNCC_DEBUG)
override CXXFLAGS += $(CL_SUNCC_DEBUG)
endif
endif
endif

ifndef CL_GCC_OPTIMIZE
CL_GCC_OPTIMIZE = -O2
endif
ifndef CL_SUNCC_OPTIMIZE
CL_SUNCC_OPTIMIZE = -O
endif

ifdef CL_OPTIMIZE
ifeq ($(CL_COMP),gcc)
override CFLAGS += $(CL_GCC_OPTIMIZE)
override CXXFLAGS += $(CL_GCC_OPTIMIZE)
endif
ifeq ($(CL_COMP),suncc)
override CFLAGS += $(CL_SUNCC_OPTIMIZE)
override CXXFLAGS += $(CL_SUNCC_OPTIMIZE)
endif
endif

# Additional defines for debugging and optimizing
# $(CL_DEFINES_DEBUG) - defaults to "-DDEBUG" if no one of DEBUG vars is set
# $(CL_DEFINES_OPTIMIZE)- defaults to "-DNDEBUG" if no one of DEBUG vars is set
# $(CL_DEFINES_DEBUG_GCC)
# $(CL_DEFINES_OPTIMIZE_GCC)
# $(CL_DEFINES_DEBUG_SUNCC)
# $(CL_DEFINES_OPTIMIZE_SUNGCC)

ifeq ($(CL_DEFINES_DEBUG)$(CL_DEFINES_DEBUG_GCC)$(CL_DEFINES_DEBUG_SUNCC),)
CL_DEFINES_DEBUG = -DDEBUG
endif
ifeq ($(CL_DEFINES_OPTIMIZE)$(CL_DEFINES_OPTIMIZE_GCC)$(CL_DEFINES_OPTIMIZE_SUNCC),)
CL_DEFINES_OPTIMIZE = -DNDEBUG
endif

ifdef CL_OPTIMIZE

override DEFINES += $(CL_DEFINES_OPTIMIZE)
ifeq ($(CL_COMP),gcc)
override DEFINES += $(CL_DEFINES_OPTIMIZE_GCC)
endif
ifeq ($(CL_COMP),suncc)
override DEFINES += $(CL_DEFINES_OPTIMIZE_SUNCC)
endif

else
ifndef CL_NDEBUG

override DEFINES += $(CL_DEFINES_DEBUG)
ifeq ($(CL_COMP),gcc)
override DEFINES += $(CL_DEFINES_DEBUG_GCC)
endif
ifeq ($(CL_COMP),suncc)
override DEFINES += $(CL_DEFINES_DEBUG_SUNCC)
endif

endif
endif


# Additional compiler flags may be passed via the following variables:
# $(CL_CC_CFLAGS) for any C compiler
# $(CL_CC_CXXFLAGS) for any C++ compiler
# $(CL_GCC_CFLAGS) for gcc
# $(CL_GCC_CXXFLAGS) for g++
# $(CL_SUNCC_CFLAGS) for cc
# $(CL_SUNCC_CXXFLAGS) for CC

override CFLAGS += $(CL_CC_CFLAGS)
override CXXFLAGS += $(CL_CC_CXXFLAGS)

ifeq ($(CL_COMP),gcc)
override CFLAGS += $(CL_GCC_CFLAGS)
override CXXFLAGS += $(CL_GCC_CXXFLAGS)
endif

ifeq ($(CL_COMP),suncc)
override CFLAGS += $(CL_SUNCC_CFLAGS)
override CXXFLAGS += $(CL_SUNCC_CXXFLAGS)
endif


# Library building tools

ifdef LIBRARY

# If CL_LTYPE is 'shared', gcc -shared is used
# $(LIBRARY) is library name.
# For shared libraries, $(LIBRARY_VERSION) and $(LIBRARY_REVISION) may be also
# used. $(LIBRARY_VERSION) will be built into soname

ifeq ($(CL_LTYPE),shared)
CL_LIBRARY_CNAME = lib$(LIBRARY).so
ifdef LIBRARY_VERSION
CL_LIBRARY_SONAME = lib$(LIBRARY).so.$(LIBRARY_VERSION)
ifdef LIBRARY_REVISION
CL_LIBRARY_FNAME = lib$(LIBRARY).so.$(LIBRARY_VERSION).$(LIBRARY_REVISION)
else
CL_LIBRARY_FNAME = lib$(LIBRARY).so.$(LIBRARY_VERSION)
endif
else
CL_LIBRARY_SONAME = lib$(LIBRARY).so
CL_LIBRARY_FNAME = lib$(LIBRARY).so
endif
# We support only gcc.
# We use -h instead of -soname because we want sun ld to work
override CFLAGS += -fPIC
override CXXFLAGS += -fPIC
CL_MKLIB := $(LD) -shared -Wl,-h,$(CL_LIBRARY_SONAME) -o
endif

ifeq ($(CL_LTYPE),static)
CL_LIBRARY_FNAME = lib$(LIBRARY).a
ifeq ($(CL_COMP),gcc)
CL_MKLIB := ar cr
endif
ifeq ($(CL_COMP),suncc)
ifeq ($(LD),CC)
# Here we want $(INCLUDES) and $(DEFINES) to be substituted later, so we use
# = instead on :=
CL_MKLIB = CC -xar -ptr$(CL_BD) $(DEFINES) $(INCLUDES) -o
else
CL_MKLIB := ar cr
endif
endif
endif

endif  # ifdef LIBRARY


# Include additional rules for used module working installations

ifdef CL_LOCALWORK
include $(CL_DIR)/rules.cvslvk
endif


# RPATH flag differs between gcc and suncc
# (not all gcc revisions understand -R: linux one doesn't)

ifeq ($(CL_COMP),gcc)
override CL_RPATH_FLAG := -Wl,-R
endif
ifeq ($(CL_COMP),suncc)
override CL_RPATH_FLAG := -R
endif


# Split LDFLAGS into -L..., -l... and others

override CL_LDFLAGS_DIRS := $(filter -L%,$(LDFLAGS))
override CL_LDFLAGS_LIBS := $(filter -l%,$(LDFLAGS))
override CL_LDFLAGS_OTHER := $(filter-out $(CL_LDFLAGS_DIRS) $(CL_LDFLAGS_LIBS),$(LDFLAGS))


# Internal library variables
#
# Executable may use some internal libraries (libraries from the same module).
# The subdirs should be in CL_USE_IL variable
# Current restrictions:
#   each library should be in a subdir;
#   subdir name and library name should be the same 
# The subdirs of the used internal libraries should be in CL_USE_IL variable
# When internal libraries are used, executable is linked separately during build
# and during installation.
# During build, rpaths to the build directories of the shared libraries are
# set, and during install - rpaths for the install directory is set

ifneq ($(CL_USE_IL),)
# Do NOT add subdirs for install or clean
ifeq ($(filter install clean,$(MAKECMDGOALS)),)
override SUBDIRS := $(CL_USE_IL) $(filter-out $(CL_USE_IL),$(SUBDIRS))
endif
# includes may be just added to $(INCLUDES)
override INCLUDES += $(CL_USE_IL:%=-I%)
# -l flags also may be just added to $(CL_LDFLAGS_LIBS)
override CL_IL_LIBS_TMP := $(notdir $(CL_USE_IL))
override CL_LDFLAGS_LIBS += $(CL_IL_LIBS_TMP:%=-l%)
# -L flags can't be just added because of rpath logic, so we use $(CL_LDFLAGS_OTHER)
override CL_IL_DIRS := $(CL_USE_IL:%=-L%)
override CL_PWD := $(shell pwd)
ifeq ($(MAKECMDGOALS),install)
override CL_LDFLAGS_OTHER += $(CL_IL_DIRS) $(CL_RPATH_FLAG)$(CL_PREFIX)/lib
else
override CL_LDFLAGS_OTHER += $(CL_IL_DIRS) $(CL_IL_DIRS:-L%=$(CL_RPATH_FLAG)$(CL_PWD)/%)
endif
endif


# Reorder the libraries if necessary
ifneq ($(CL_LIBORDER),)
override CL_LDFLAGS_LIBS := $(shell $(CL_HELPER) liborder $(CL_LIBORDER) -- $(CL_LDFLAGS_LIBS))
endif

# Compute the final LDFLAGS (with compiler-dependent RPATH functionality)
override LDFLAGS := $(CL_LDFLAGS_DIRS) $(CL_LDFLAGS_DIRS:-L%=$(CL_RPATH_FLAG)%) $(CL_LDFLAGS_LIBS) $(CL_LDFLAGS_OTHER)


# Add $(INCLUDES) and $(DEFINES) to $(C{XX}FLAGS)
override CFLAGS += $(INCLUDES) $(DEFINES)
override CXXFLAGS += $(INCLUDES) $(DEFINES)


# Create $(CL_SOURCES_ALL) and $(CL_OBJECTS_ALL)
# Assumptions:
# $(SOURCES) contains user sources
# $(CL_SOURCES_NU) and $(CL_OBJECTS_NU) contain non-user sources and objects
# The later is not automatically generated because methods differ.

ifdef CL_LOCALWORK
override CL_SOURCES_ALL := $(CL_SOURCES_NU) $(SOURCES)
override OBJECTS := $(SOURCES:%=$(CL_BD)/%)
override OBJECTS := $(OBJECTS:.cpp=.o)
override OBJECTS := $(OBJECTS:.cc=.o)
override OBJECTS := $(OBJECTS:.C=.o)
override OBJECTS := $(OBJECTS:.mm=.o)
override OBJECTS := $(OBJECTS:.c=.o)
override CL_OBJECTS_ALL := $(CL_OBJECTS_NU) $(OBJECTS)
endif


# Autodepend rules
# No dependences needed when making $(CL_NODEP_RULES) - e.g. clean, show_wi

ifdef CL_LOCALWORK

override DEPS := $(SOURCES:%=$(CL_BD)/%.deps)
override CL_DEPS_ALL := $(CL_DEPS_NU) $(DEPS)

# There is a problem that we can't just call "cpp -MM" because at least gcc
# passes to cpp tons of defined.
# We will save some flags in $(CL_BD)/SYS_MKDEP_FLAGS_C{XX}
# Currently this is done correctly for gcc only (using gcc -v)

override CL_SYS_CFLAGS := $(filter-out -I% -D% -c,$(CFLAGS))
$(CL_BD)/SYS_MKDEP_FLAGS_C:
	@$(CL_HELPER) make_sys_mkdep_flags_c $(CL_BD) $(CL_COMP) $(CL_SYS_CFLAGS)

override CL_SYS_CXXFLAGS := $(filter-out -I% -D% -c,$(CXXFLAGS))
$(CL_BD)/SYS_MKDEP_FLAGS_CXX:
	@$(CL_HELPER) make_sys_mkdep_flags_cxx $(CL_BD) $(CL_COMP) $(CL_SYS_CXXFLAGS)

$(CL_DEPS_ALL): $(CL_BD)/SYS_MKDEP_FLAGS_C $(CL_BD)/SYS_MKDEP_FLAGS_CXX


$(CL_BD)/%.deps: %
	@$(CL_HELPER) depend $< $@ $(INCLUDES) $(DEFINES)

$(CL_BD)/%.deps: $(CL_BD)/%
	@$(CL_HELPER) depend $< $@ $(INCLUDES) $(DEFINES)

CL_NODEP_RULES += clean cleanall create_wi update_wi install

ifneq ($(MAKECMDGOALS),)
ifeq ($(filter-out $(CL_NODEP_RULES),$(MAKECMDGOALS)),)
CL_NODEP_WORKED = 1
endif
endif

# We include only those deps files that are currently available
# To automatically rebuild dependences, we set up this makefile to be dependent
# from all needed deps. Since GNU make always tries to remake makefile, this
# enables all required dependences to be built

ifndef CL_NODEP_WORKED

$(CL_DIR)/Makefile.cvslvk: $(CL_DEPS_ALL)

ifneq ($(CL_PRE_DEPEND),)
$(CL_DEPS_ALL): $(CL_PRE_DEPEND)
endif

override CL_DEPS_TO_INCLUDE := $(filter $(CL_DEPS_ALL),$(wildcard $(CL_BD)/*.deps))
ifneq ($(CL_DEPS_TO_INCLUDE),)
include $(CL_DEPS_TO_INCLUDE)
endif

# Rebuild on changes of CL_WI_LIST or compiler flags
# Rebuild on changes in WIs rules
# Relink on changes of LDFLAGS
# First, touch corresponding files in $(CL_BD) if parameters changed
# (Use single complex shell command to make things faster)
override CL_TMP := $(shell $(CL_HELPER) touchap $(CL_BD) WILIST $(CL_WI_LIST) -- ALLCOMPILEFLAGS $(CFLAGS) $(CXXFLAGS) -- LINKFLAGS $(LDFLAGS))
$(CL_OBJECTS_ALL) $(CL_DEPS_ALL) : $(CL_BD)/WILIST $(CL_BD)/ALLCOMPILEFLAGS $(filter $(CL_WI_LIST:%=$(CL_DIR)/%/rules.cvslvk),$(wildcard $(CL_DIR)/*/rules.cvslvk))
ifneq ($(EXECUTABLE),)
override CL_TMP := $(filter -L%, $(LDFLAGS))
ifneq ($(CL_TMP),)
vpath lib%.so $(CL_TMP:-L%=%)
vpath lib%.a $(CL_TMP:-L%=%)
endif
$(CL_BD)/$(EXECUTABLE) : $(CL_BD)/LINKFLAGS $(filter -l%, $(LDFLAGS))
endif
ifneq ($(CL_LIBRARY_FNAME),)
$(CL_BD)/$(CL_LIBRARY_FNAME) : $(CL_BD)/LINKFLAGS
endif

endif  # ifndef CL_NODEP_WORKED

endif  # CL_LOCALWORK


# Rule to create and update working installation.
# $(CL_MODULE) is the module name
# $(CL_VERSION) is the wi version, defaults to 'unknown'
# $(CL_INFO) is the third part of the wi name, defaults to $(CL_DIR_PARAMS)
# Sets $(CL_PREFIX) and uses make install


override CL_WI_DIR := $(CL_MODULE)_$(CL_DIR_PARAMS)

create_wi: $(ALWAYS)
	@echo
	@echo Creating working installation $(CL_WI_DIR) ...
	@echo
	@$(CL_HELPER) before_create_wi $(CL_WI_DIR)
	@echo Running $(MAKE) all CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) ...
	@echo
	@$(MAKE) all CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR)
	@$(CL_HELPER) before_install_wi $(CL_WI_DIR)
	@echo
	@echo Running $(MAKE) install CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) ...
	@echo
	@$(MAKE) install CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) CL_INSTALL_WI=1
	@$(CL_HELPER) complete_wi $(CL_WI_DIR)
	@echo

update_wi: $(ALWAYS)
	@if test -d $(CL_DIR)/$(CL_WI_DIR); then \
	  echo; \
	  echo Removing available working installation $(CL_WI_DIR) ...; \
	  $(CL_HELPER) remove_wi $(CL_WI_DIR); \
	  echo; fi
	@make create_wi


# Rules for building object files

ifdef CL_LOCALWORK

$(CL_BD)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ $<

$(CL_BD)/%.o: $(CL_BD)/%.c
	$(CC) $(CFLAGS) -o $@ $<

$(CL_BD)/%.o: %.cpp
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: $(CL_BD)/%.cpp
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: %.cc
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: %.C
	$(CXX) $(CXXFLAGS) -o $@ $<

endif


# Install rules (all are used as the dependences of "install" rule)

ifdef EXECUTABLE
install_executable: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/bin
	rm -f $(CL_PREFIX)/bin/$(EXECUTABLE)
ifdef CL_USE_IL
	$(LD) $(CL_OBJECTS_ALL) $(LDFLAGS) $(CL_IL_LDFLAGS_INSTALL) -o $(CL_PREFIX)/bin/$(EXECUTABLE)
else
	cp $(CL_BD)/$(EXECUTABLE) $(CL_PREFIX)/bin/
endif

override CL_INSTALL_PARTS += install_executable
endif

ifdef LIBRARY

ifeq ($(CL_LTYPE),shared)
install_library: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/lib
	rm -f $(CL_PREFIX)/lib/$(CL_LIBRARY_FNAME)
	cp $(CL_BD)/$(CL_LIBRARY_FNAME) $(CL_PREFIX)/lib/
ifneq ($(CL_LIBRARY_SONAME), $(CL_LIBRARY_FNAME))
	(cd $(CL_PREFIX)/lib && rm -f $(CL_LIBRARY_SONAME) && ln -s $(CL_LIBRARY_FNAME) $(CL_LIBRARY_SONAME))
endif
ifneq ($(CL_LIBRARY_CNAME), $(CL_LIBRARY_SONAME))
ifndef INTERNAL_LIBRARY
	(cd $(CL_PREFIX)/lib && rm -f $(CL_LIBRARY_CNAME) && ln -s $(CL_LIBRARY_SONAME) $(CL_LIBRARY_CNAME))
endif
endif
ifdef INTERNAL_LIBRARY
ifdef OPTIMIZE
	strip $(CL_PREFIX)/lib/$(CL_LIBRARY_FNAME)
endif
endif

override CL_INSTALL_PARTS += install_library
endif # shared

ifeq ($(CL_LTYPE),static)
ifndef INTERNAL_LIBRARY
install_library: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/lib
	rm -f $(CL_PREFIX)/lib/$(CL_LIBRARY_FNAME)
	cp $(CL_BD)/$(CL_LIBRARY_FNAME) $(CL_PREFIX)/lib/

override CL_INSTALL_PARTS += install_library
endif
endif # static

endif # LIBRARY


ifdef EXPORT_INCLUDES
install_includes: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/include
	( cd $(CL_PREFIX)/include && rm -rf $(EXPORT_INCLUDES) )
	cp -r $(EXPORT_INCLUDES) $(CL_PREFIX)/include/

override CL_INSTALL_PARTS += install_includes
endif

ifdef SCRIPTS
install_scripts: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/bin
	( cd $(CL_PREFIX)/bin && rm -rf $(SCRIPTS) )
	cp $(SCRIPTS) $(CL_PREFIX)/bin/

override CL_INSTALL_PARTS += install_scripts
endif

ifdef SCRIPTS_WI
ifdef CL_INSTALL_WI
install_scripts_wi: $(ALWAYS)
	mkdir -p $(CL_PREFIX)/bin
	( cd $(CL_PREFIX)/bin && rm -rf $(SCRIPTS_WI) )
	cp $(SCRIPTS_WI) $(CL_PREFIX)/bin/

override CL_INSTALL_PARTS += install_scripts_wi
endif
endif

ifdef SUBDIRS
override CL_INSTALL_PARTS += install_subdirs
endif

ifdef CL_INSTALL_WI
override CL_WI_DEPEND := $(foreach dep,$(CL_DEPEND_ON_EXACT),$(filter $(dep)_%,$(CL_WI_LIST)))
install_rules: $(ALWAYS)
	if test -f rules.cvslvk; then rm -f $(CL_PREFIX)/rules.cvslvk && cp rules.cvslvk $(CL_PREFIX)/; fi
	if test -f depend.cvslvk; then rm -f $(CL_PREFIX)/depend.cvslvk && cp depend.cvslvk $(CL_PREFIX)/; fi
ifneq ($(strip $(CL_WI_DEPEND)),)
	printf "\n%s\n" $(CL_WI_DEPEND) >> $(CL_PREFIX)/depend.cvslvk
endif

override CL_INSTALL_PARTS += install_rules
endif

install: all $(CL_INSTALL_PARTS) $(ALWAYS)


ifdef SUBDIRS
all_subdirs install_subdirs clean_subdirs cleanall_subdirs: $(ALWAYS)
	for dir in $(SUBDIRS); do \
	  (cd $$dir && $(MAKE) `echo $@ | cut -d_ -f1`) || exit 1; \
	done
override CL_CLEAN := clean_subdirs $(CL_CLEAN)
ifeq ($(EXECUTABLE)$(LIBRARY),)
all: all_subdirs
endif
else # No SUBDIRS
all_subdirs cleanall_subdirs:
endif # SUBDIRS


ifdef EXECUTABLE

ifneq ($(CL_SYMLINKS),)
override CL_SL_NAMES := $(notdir $(CL_SYMLINKS))
$(CL_SL_NAMES):
	@echo $(CL_SL_NAMES) > $(CL_BD)/SYMLINKS 2>/dev/null || true
	rm -f $(CL_SL_NAMES) && ln -s $(CL_SYMLINKS) .
override CL_CLEAN_FILES += $(CL_SL_NAMES)
endif

all: all_subdirs $(EXECUTABLE) $(CL_SL_NAMES)

$(EXECUTABLE): $(CL_BD)/$(EXECUTABLE)
	rm -f  $(EXECUTABLE) && ln -s $(CL_BD)/$(EXECUTABLE) $(EXECUTABLE)

$(CL_BD)/$(EXECUTABLE): $(CL_OBJECTS_ALL)
	$(LD) $(CL_OBJECTS_ALL) $(LDFLAGS) $(CL_IL_LDFLAGS_BUILD) -o $@ 
ifdef CL_OPTIMIZE
	strip $@
endif

override CL_CLEAN_FILES += $(EXECUTABLE)

endif


ifdef LIBRARY

override CL_ALL_LIB_NAMES := $(CL_LIBRARY_FNAME)
ifeq ($(CL_LTYPE),shared)
ifneq ($(CL_LIBRARY_SONAME), $(CL_LIBRARY_FNAME))
override CL_ALL_LIB_NAMES += $(CL_LIBRARY_SONAME)
endif
ifneq ($(CL_LIBRARY_CNAME), $(CL_LIBRARY_SONAME))
override CL_ALL_LIB_NAMES += $(CL_LIBRARY_CNAME)
endif
endif

all: all_subdirs $(CL_ALL_LIB_NAMES)

$(CL_ALL_LIB_NAMES): $(CL_ALL_LIB_NAMES:%=$(CL_BD)/%)
	rm -f $@ && ln -s $(CL_BD)/$@ .

$(CL_BD)/$(CL_LIBRARY_FNAME): $(CL_OBJECTS_ALL)
	$(CL_MKLIB) $@ $(CL_OBJECTS_ALL)

ifeq ($(CL_LTYPE),shared)
ifneq ($(CL_LIBRARY_SONAME), $(CL_LIBRARY_FNAME))
$(CL_BD)/$(CL_LIBRARY_SONAME): $(CL_BD)/$(CL_LIBRARY_FNAME)
	(cd $(CL_BD) && rm -f $(CL_LIBRARY_SONAME) && ln -s $(CL_LIBRARY_FNAME) $(CL_LIBRARY_SONAME))
endif
ifneq ($(CL_LIBRARY_CNAME), $(CL_LIBRARY_SONAME))
$(CL_BD)/$(CL_LIBRARY_CNAME): $(CL_BD)/$(CL_LIBRARY_SONAME)
	(cd $(CL_BD) && rm -f $(CL_LIBRARY_CNAME) && ln -s $(CL_LIBRARY_SONAME) $(CL_LIBRARY_CNAME))
endif
endif

override CL_CLEAN_FILES += $(CL_ALL_LIB_NAMES)

endif


# The generic "clean" rule
# Uses $(CL_CLEAN) as a list of additional rules and $(CL_CLEAN_FILES) as a list
# for "rm -rf"

ifneq ($(MAKECMDGOALS),cleanall)
override CL_CLEAN_FILES := $(CL_BD) $(CL_CLEAN_FILES)
endif

clean: $(CL_CLEAN) $(ALWAYS)
	rm -rf $(CL_CLEAN_FILES)

# "cleanall" rule - removes ALL build directories
# Those are identified via stamp files

cleanall: cleanall_subdirs $(CL_CLEAN) $(ALWAYS)
	rm -rf $(CL_CLEAN_FILES)
	@$(CL_HELPER) cleanall
