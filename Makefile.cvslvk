# The include-makefile for CVS-LVK projects.


HELPER = $(CL_DIR)/cvslvk


# $(CL_DEFAULT_GOAL) - what to make when "make" is run with no parameters
# Defaults to "all".

ifndef CL_DEFAULT_GOAL
CL_DEFAULT_GOAL = all
endif

default_goal: $(CL_DEFAULT_GOAL)


# $(ALWAYS) macro - a rule that should be applied even if file exists
#   ( usage:   xxx : $(ALWAYS) )

ALWAYS = /etc/file_that_never_exists

$(ALWAYS):


# If no command is given, stop immidiatly

ifeq ($(EXECUTABLE)$(LIBRARY)$(SUBDIRS),)
override CL_TMP := $(shell $(HELPER) error cvslvk: cannot determine mode. Please set EXECUTABLE, LIBRARY or SUBDIRS)
endif

# Are we going to do anything in the current directory ?
# If no, then most of the settings may be omitted

ifneq ($(EXECUTABLE)$(LIBRARY),)
CL_LOCALWORK = 1
endif


# Architecture and OS are those we are using
# These are detected automatically using 'uname', but since 'uname' output
# is os- and architecture-dependent, we use a wrapper in $(HELPER)
# Currently supported: solaris and linux, on x86 and sparc

override CL_ARCH := $(shell $(HELPER) get_arch)
override CL_OS := $(shell $(HELPER) get_os)


# Compiler defaults to GCC. Sun CC may be still used, if $(CL_COMP)=suncc
# $(CL_COMP) should be 'gcc' or 'suncc'

ifndef CL_COMP
CL_COMP = gcc
endif

override CL_TMP := $(shell $(HELPER) check_enum CL_COMP=$(CL_COMP) gcc suncc)


# Set C and C++ compilers

ifeq ($(CL_COMP),gcc)
override CC = gcc
override CXX = g++
endif
ifeq ($(CL_COMP),suncc)
override CC = cc
override CXX = CC
endif


# Set linker. If all user sources are .c files, linker will default to $(CC)
# Otherwise, it will default to $(CXX)

override CL_TMP := $(filter-out %.c, $(SOURCES))
ifeq ($(CL_TMP),)
override LD := $(CC)
else
override LD := $(CXX)
endif


# $(CL_LTYPE) defaults to 'shared' for gcc, 'static' for suncc
# Building shared libraries with suncc is not yet supported

ifndef CL_LTYPE
ifeq ($(CL_COMP),gcc)
CL_LTYPE = shared
endif
ifeq ($(CL_COMP),suncc)
CL_LTYPE = static
endif
endif

override CL_TMP := $(shell $(HELPER) check_enum CL_LTYPE=$(CL_LTYPE) shared static)

ifeq ($(CL_COMP)-$(CL_LTYPE),suncc-shared)
override CL_TMP := $(shell $(HELPER) error Building shared libraries with suncc is not yet supported)
endif


# Variable check subsystem

# To check variables, set CL_VARS. The format is the following:
# CL_VARS = MYVAR=$(MYVAR) MYVAR2=$(MYVAR2) ...

ifdef CL_PARAM_OTHERP
override CL_VARS += CL_OTHERP=$(CL_OTHERP)
endif

ifneq ($(CL_VARS),)
override CL_TMP := $(shell $(HELPER) check_vars $(CL_VARS))
endif


# Build directory parameters.
# All generated files will be placed into a subdir
#
# The combination of variables that are used to find out build parameters
# is the following.
# Always CL_ARCH, CL_OS are used, together with optimization and
# debugging flags.
#
# CL_COMP is used if CL_PARAM_COMP is defined, or if we are building
# a c++ library, or if we use a module that has CL_COMP in params
#
# CL_LTYPE is used, if CL_PARAM_LTYPE is defined, or if we are building library
#
# CL_OTHER is used, if CL_PARAM_LTYPE is defined

override CL_DIR_PARAMS := $(CL_ARCH)-$(CL_OS)

ifndef CL_PARAM_COMP
ifdef LIBRARY
ifeq ($(LD),$(CXX))
CL_PARAM_COMP = 1
endif
endif
ifeq ($(shell $(HELPER) need_comp_param $(CL_USE_MODULES)),yes)
CL_PARAM_COMP = 1
endif
endif
ifdef CL_PARAM_COMP
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_COMP)
endif

ifdef LIBRARY
CL_PARAM_LTYPE = 1
endif
ifdef CL_PARAM_LTYPE
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_LTYPE)
endif

ifdef CL_PARAM_OTHERP
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-$(CL_OTHERP)
endif

ifdef CL_OPTIMIZE
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-optimized
else
ifndef CL_NDEBUG
override CL_DIR_PARAMS := $(CL_DIR_PARAMS)-debug
endif
endif

# Now $(CL_DIR_PARAMS) is the parameter string

override CL_BD := $(CL_DIR_PARAMS)
ifdef CL_LOCALWORK
override CL_TMP := $(shell mkdir -p $(CL_BD))  # Create build directory
endif

# Since some include files may be generated, we want to add $(CL_BD) to
# include search path. -I. is needed because without it, includes are searched
# in -I's only

ifdef CL_LOCALWORK
override INCLUDES += -I. -I$(CL_BD)
endif


# Compiler flags for debugging and optimizing
# By default, everything is built with debug information
# If CL_NDEBUG is set, everything will be built with no debug information
# If CL_OPTIMIZE is set, everything will be built with optimizations AND
# without debug information (optimization + gebug information is useless)
# For debugging with gcc, $(CL_GCC_DEBUG) is used, defaults to -g
# For debugging with suncc, $(CL_SUNCC_DEBUG) is used, defaults to -g
# For optimizing with gcc, $(CL_GCC_OPTIMIZE) is used, defaults to -O2 -DNDEBUG
# For optimizing with suncc, $(CL_SUNCC_OPTIMIZE) is used, defaults to -O -DNDEBUG

override CFLAGS := -c
override CXXFLAGS := -c

# Handle sun CC's templates database
ifeq ($(CL_COMP),suncc)
override CXXFLAGS += -ptr$(CL_BD)
ifeq ($(LD),CC)
override LDFLAGS += -ptr$(CL_BD)
endif
endif

ifndef CL_GCC_DEBUG
CL_GCC_DEBUG = -g
endif
ifndef CL_SUNCC_DEBUG
CL_SUNCC_DEBUG = -g
endif

ifndef CL_NDEBUG
ifndef CL_OPTIMIZE
ifeq ($(CL_COMP),gcc)
override CFLAGS += $(CL_GCC_DEBUG)
override CXXFLAGS += $(CL_GCC_DEBUG)
endif
ifeq ($(CL_COMP),suncc)
override CFLAGS += $(CL_SUNCC_DEBUG)
override CXXFLAGS += $(CL_SUNCC_DEBUG)
endif
endif
endif

ifndef CL_GCC_OPTIMIZE
CL_GCC_OPTIMIZE = -O2 -DNDEBUG
endif
ifndef CL_SUNCC_OPTIMIZE
CL_SUNCC_OPTIMIZE = -O -DNDEBUG
endif

ifdef CL_OPTIMIZE
ifeq ($(CL_COMP),gcc)
override CFLAGS += $(CL_GCC_OPTIMIZE)
override CXXFLAGS += $(CL_GCC_OPTIMIZE)
endif
ifeq ($(CL_COMP),suncc)
override CFLAGS += $(CL_SUNCC_OPTIMIZE)
override CXXFLAGS += $(CL_SUNCC_OPTIMIZE)
endif
endif

# Additional compiler flags may be passed via the following variables:
# $(CL_CC_FLAGS) for any compiler
# $(CL_CC_CFLAGS) for any C compiler
# $(CL_CC_CXXFLAGS) for any C++ compiler
# $(CL_GCC_FLAGS) for gcc and g++
# $(CL_GCC_CFLAGS) for gcc
# $(CL_GCC_CXXFLAGS) for g++
# $(CL_SUNCC_FLAGS) for cc and CC
# $(CL_SUNCC_CFLAGS) for cc
# $(CL_SUNCC_CXXFLAGS) for CC

ifdef CL_CC_FLAGS
override CFLAGS += $(CL_CC_FLAGS)
override CXXFLAGS += $(CL_CC_FLAGS)
endif
ifdef CL_CC_CFLAGS
override CFLAGS += $(CL_CC_CFLAGS)
endif
ifdef CL_CC_CXXFLAGS
override CXXFLAGS += $(CL_CC_CXXFLAGS)
endif

ifeq ($(CL_COMP),gcc)
ifdef CL_GCC_FLAGS
override CFLAGS += $(CL_GCC_FLAGS)
override CXXFLAGS += $(CL_GCC_FLAGS)
endif
ifdef CL_GCC_CFLAGS
override CFLAGS += $(CL_GCC_CFLAGS)
endif
ifdef CL_GCC_CXXFLAGS
override CXXFLAGS += $(CL_GCC_CXXFLAGS)
endif
endif

ifeq ($(CL_COMP),suncc)
ifdef CL_SUNCC_FLAGS
override CFLAGS += $(CL_SUNCC_FLAGS)
override CXXFLAGS += $(CL_SUNCC_FLAGS)
endif
ifdef CL_SUNCC_CFLAGS
override CFLAGS += $(CL_SUNCC_CFLAGS)
endif
ifdef CL_SUNCC_CXXFLAGS
override CXXFLAGS += $(CL_SUNCC_CXXFLAGS)
endif
endif


# Library building tools

ifdef LIBRARY

# If CL_LTYPE is 'shared', gcc -shared is used
# $(LIBRARY) is library name.
# For shared libraries, $(LIBRARY_VERSION) and $(LIBRARY_REVISION) may be also
# used. $(LIBRARY_VERSION) will be built into soname

ifeq ($(CL_LTYPE),shared)
CL_LIBRARY_CNAME = lib$(LIBRARY).so
ifdef LIBRARY_VERSION
CL_LIBRARY_SONAME = lib$(LIBRARY).so.$(LIBRARY_VERSION)
ifdef LIBRARY_REVISION
CL_LIBRARY_FNAME = lib$(LIBRARY).so.$(LIBRARY_VERSION).$(LIBRARY_REVISION)
else
CL_LIBRARY_FNAME = lib$(LIBRARY).so.$(LIBRARY_VERSION)
endif
else
CL_LIBRARY_SONAME = lib$(LIBRARY).so
CL_LIBRARY_FNAME = lib$(LIBRARY).so
endif
# We support only gcc
override CFLAGS += -fPIC
override CXXFLAGS += -fPIC
CL_MKLIB := $(LD) -shared -Wl,-h,$(CL_LIBRARY_SONAME) -o
endif

ifeq ($(CL_LTYPE),static)
CL_LIBRARY_FNAME = lib$(LIBRARY).a
ifeq ($(CL_COMP),gcc)
CL_MKLIB := ar cr
endif
ifeq ($(CL_COMP),suncc)
ifeq ($(LD),CC)
# Here we want $(INCLUDES) and $(DEFINES) to be substituted later, so we use
# = instead on :=
CL_MKLIB = CC -xar -ptr$(CL_BD) $(DEFINES) $(INCLUDES) -o
else
CL_MKLIB := ar cr
endif
endif
endif

endif  # ifdef LIBRARY


# Find the available module installations and replace user references by
# actual installations. Then include definitions for used modules

ifdef CL_LOCALWORK
override CL_MODULES_WI := $(shell $(HELPER) find_modules $(CL_DIR_PARAMS) $(CL_USE_MODULES))

$(CL_DIR)/rules.cvslvk:
	@$(HELPER) make_rules

include $(CL_DIR)/rules.cvslvk
endif

# 'show_wi' rule - will show what working installes are being used

show_wi: $(ALWAYS)
	@$(HELPER) show_wi $(CL_USE_MODULES) -- $(CL_MODULES_WI)

# If the rule is not 'show_wi', abort if wi's are not available

ifdef CL_LOCALWORK
ifneq ($(MAKECMDGOALS),show_wi)
override CL_TMP := $(shell $(HELPER) check_wi $(CL_USE_MODULES) -- $(CL_MODULES_WI))
endif
endif


# Now we can add $(INCLUDES) and $(DEFINES) to $(C{XX}FLAGS)

override CFLAGS += $(INCLUDES) $(DEFINES)
override CXXFLAGS += $(INCLUDES) $(DEFINES)


# Create $(CL_SOURCES_ALL) and $(CL_OBJECTS_ALL)
# Assumptions:
# $(SOURCES) contains user sources
# $(CL_SOURCES_NU) and $(CL_OBJECTS_NU) contain non-user sources and objects
# The later is not automatically generated because methods differ.
#
# $(CL_SOURCES_NU) should be before $(SOURCES), because generated headers
# may be used when dependences are calculated for user files

ifdef CL_LOCALWORK
override CL_SOURCES_ALL := $(CL_SOURCES_NU) $(SOURCES)
override OBJECTS := $(SOURCES:%=$(CL_BD)/%)
override OBJECTS := $(OBJECTS:.cpp=.o)
override OBJECTS := $(OBJECTS:.cc=.o)
override OBJECTS := $(OBJECTS:.C=.o)
override OBJECTS := $(OBJECTS:.mm=.o)
override OBJECTS := $(OBJECTS:.c=.o)
override CL_OBJECTS_ALL := $(CL_OBJECTS_NU) $(OBJECTS)
endif


# Autodepend rules
# No dependences needed when making $(CL_NODEP_RULES) - e.g. clean, show_wi

ifdef CL_LOCALWORK

override DEPS := $(SOURCES:%=$(CL_BD)/%.deps)
override CL_DEPS_ALL := $(CL_DEPS_NU) $(DEPS)

$(CL_BD)/%.deps: %
	@$(HELPER) depend $< $@ $(INCLUDES) $(DEFINES)

$(CL_BD)/%.deps: $(CL_BD)/%
	@$(HELPER) depend $< $@ $(INCLUDES) $(DEFINES)

CL_NODEP_RULES += clean show_wi create_wi update_wi

ifneq ($(MAKECMDGOALS),)
ifeq ($(filter-out $(CL_NODEP_RULES),$(MAKECMDGOALS)),)
CL_NODEP_WORKED = 1
endif
endif

# We include only those deps files that are currently available
# To automatically rebuild dependences, we set up this makefile to be dependent
# from all needed deps. Since GNU make always tries to remake makefile, this
# enables all required dependences to be built

ifndef CL_NODEP_WORKED

$(CL_DIR)/Makefile.cvslvk: $(CL_DEPS_ALL)

override CL_DEPS_TO_INCLUDE := $(filter $(CL_DEPS_ALL),$(wildcard $(CL_BD)/*.deps))
ifneq ($(CL_DEPS_TO_INCLUDE),)
include $(CL_DEPS_TO_INCLUDE)
endif

endif  # ifndef CL_NODEP_WORKED

endif  # CL_LOCALWORK


# Rule to create and update working installation.
# $(CL_MODULE) is the module name
# $(CL_VERSION) is the wi version, defaults to 'unknown'
# $(CL_INFO) is the third part of the wi name, defaults to $(CL_DIR_PARAMS)
# Sets $(CL_PREFIX) and uses make install


ifndef CL_VERSION
CL_VERSION := unknown
endif
ifndef CL_INFO
CL_INFO := $(CL_DIR_PARAMS)
endif

override CL_WI_DIR := $(CL_MODULE)_$(CL_VERSION)_$(CL_INFO)

create_wi: $(ALWAYS)
	@$(HELPER) check_vars CL_MODULE=$(CL_MODULE)
	@echo
	@echo Creating working installation $(CL_WI_DIR) ...
	@echo
	@$(HELPER) before_create_wi $(CL_WI_DIR)
	@echo Running $(MAKE) all CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) ...
	@echo
	@$(MAKE) all CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR)
	@$(HELPER) before_install_wi $(CL_WI_DIR)
	@echo
	@echo Running $(MAKE) install CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) ...
	@echo
	@$(MAKE) install CL_PREFIX=$(CL_DIR)/$(CL_WI_DIR) CL_INSTALL_WI=1
	@$(HELPER) complete_wi $(CL_WI_DIR)
	@echo

update_wi: $(ALWAYS)
	@$(HELPER) check_vars CL_MODULE=$(CL_MODULE)
	@if test -d $(CL_DIR)/$(CL_WI_DIR); then \
	  echo; \
	  echo Removing available working installation $(CL_WI_DIR) ...; \
	  $(HELPER) remove_wi $(CL_WI_DIR); \
	  echo; fi
	@make create_wi


# Rules for building object files

ifdef CL_LOCALWORK

$(CL_BD)/%.o: %.c
	$(CC) $(CFLAGS) -o $@ $<

$(CL_BD)/%.o: $(CL_BD)/%.c
	$(CC) $(CFLAGS) -o $@ $<

$(CL_BD)/%.o: %.cpp
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: $(CL_BD)/%.cpp
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: %.cc
	$(CXX) $(CXXFLAGS) -o $@ $<

$(CL_BD)/%.o: %.C
	$(CXX) $(CXXFLAGS) -o $@ $<

endif



ifdef SUBDIRS

all_subdirs install_subdirs clean_subdirs: $(ALWAYS)
	for dir in $(SUBDIRS); do \
	  ( (cd \$dir && $(MAKE) `echo $@ | cut -f_ -d1`) || exit 1 ) \
	done

ifeq ($(EXECUTABLE)$(LIBRARY),)

all: all_subdirs

install: install_subdirs

clean: $(CL_CLEAN) clean_subdirs

endif

else

all_subdirs install_subdirs clean_subdirs:

endif


ifdef EXECUTABLE

all: $(EXECUTABLE) all_subdirs

$(EXECUTABLE): $(CL_BD)/$(EXECUTABLE)
	ln -sf $(CL_BD)/$(EXECUTABLE) $(EXECUTABLE)

$(CL_BD)/$(EXECUTABLE): $(CL_OBJECTS_ALL)
	$(LD) $(CL_OBJECTS_ALL) $(LDFLAGS) -o $@ 
ifdef CL_OPTIMIZE
	strip $@
endif

install: all install_subdirs $(ALWAYS)
	@$(HELPER) check_vars CL_PREFIX=$(CL_PREFIX)
	mkdir -p $(CL_PREFIX)/bin
	cp $(CL_BD)/$(EXECUTABLE) $(CL_PREFIX)/bin
	if test -n "$(CL_SCRIPTS)"; then cp $(CL_SCRIPTS) $(CL_PREFIX)/bin; fi
	if test -n "$(CL_INSTALL_WI)" -a -f rules.cvslvk; then cp rules.cvslvk $(CL_PREFIX); fi
	if test -n "$(CL_INSTALL_WI)" -a -n "$(CL_SCRIPTS_WI)"; then cp $(CL_SCRIPTS_WI) $(CL_PREFIX)/bin; fi

clean: $(CL_CLEAN) clean_subdirs $(ALWAYS)
	rm -rf $(CL_BD)
	rm -f $(EXECUTABLE)

endif


ifdef LIBRARY

all: $(CL_BD)/$(CL_LIBRARY_FNAME) all_subdirs

$(CL_BD)/$(CL_LIBRARY_FNAME): $(CL_OBJECTS_ALL)
	$(CL_MKLIB) $@ $(CL_OBJECTS_ALL)
ifdef CL_OPTIMIZE
	strip -g $@
endif

install: all install_subdirs $(ALWAYS)
	@$(HELPER) check_vars CL_PREFIX=$(CL_PREFIX)
	mkdir -p $(CL_PREFIX)/lib $(CL_PREFIX)/include
	cp $(CL_BD)/$(CL_LIBRARY_FNAME) $(CL_PREFIX)/lib
ifeq ($(CL_LTYPE),shared)
ifneq ($(CL_LIBRARY_SONAME), $(CL_LIBRARY_FNAME))
	(cd $(CL_PREFIX)/lib && ln -sf $(CL_LIBRARY_FNAME) $(CL_LIBRARY_SONAME))
endif
ifneq ($(CL_LIBRARY_CNAME), $(CL_LIBRARY_SONAME))
	(cd $(CL_PREFIX)/lib && ln -sf $(CL_LIBRARY_SONAME) $(CL_LIBRARY_CNAME))
endif
endif
	cp $(EXPORT_INCLUDES) $(CL_PREFIX)/include
	if test -n "$(CL_INSTALL_WI)" -a -f rules.cvslvk; then cp rules.cvslvk $(CL_PREFIX); fi

clean: $(CL_CLEAN) clean_subdirs $(ALWAYS)
	rm -rf $(CL_BD)

endif
