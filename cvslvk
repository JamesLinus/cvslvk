#!/bin/bash
# Вспомогательный скрипт для работы с CVS в ЛВК

if test "$CL_DIR" = ""; then
  echo 'CL_DIR is not set' 1>&2
  exit 1
fi

realls=`which ls`
ls()
{
  eval `locale | sed 's/\([^=]*\).*/\1=C/'` $realls $@
}

# Файл, создаваемый по cvslvk make_rules
RULES_CVSLVK=$CL_DIR/rules.cvslvk
RULES_CVSLVK_TMP=$CL_DIR/rules.cvslvk.tmp.$$  # Временная копия того же файла

# Группа пользователей CVS
CVSGROUP=stand

# Полные имена следующих двух файлов получаются добавлением к ним -<arch>-<os>
# Префикс файла со списком рабочих инсталляций и их требований
WILIST=$CL_DIR/wilist

# Файл управления автоматической сборкой
# метка:WI:модуль:тег:параметры make:комментарий
AUTOBUILD_CONF=$CL_DIR/autobuild.conf

MYPID=$$
kill_make()
{
  MAKEPID=`(echo $MYPID; ps -l) | awk -f $CL_DIR/getppid.awk`
  kill $MAKEPID;
  exit 1;
}


choose_chgrp_and_chmod()
{
  clgroup=`ls -Lld $CL_DIR | awk '{print($4)}'`
  if test "$clgroup" = "$CVSGROUP"; then
    CHGRP=chgrp
    CHMOD=chmod
  else
    CHGRP=true
    CHMOD=true
  fi
}


echo_build_error()
{
      echo 1>&2
      echo "*** ERROR ***" 1>&2
      echo 1>&2
}


# error сообщение
error()
{
  echo_build_error
  echo $* 1>&2
  echo 1>&2
  kill_make
}


# check_vars ИМЯ=значение [значение1 ...] -- ...
check_vars()
{
  error=0
  while test "" != "$1"; do
    var=`echo $1 | cut -f1 -d=`
    value=`echo $1 | cut -f2 -d=`
    shift
    if test "--" = "$1"; then
      if test "" = "$value"; then
        if test $error -eq 0; then echo_build_error; fi
        echo "Variable '$var' is not set." 1>&2
        error=1
      fi
    else
      found=0
      alts=""
      while test "--" != "$1"; do
        alts="$alts $1"
        if test "$value" = "$1"; then found=1; fi
	shift
      done
      if test $found -eq 0; then
        if test $error -eq 0; then echo_build_error; fi
        echo "Bad value '$value' of variable '$var' (supported values:$alts)." 1>&2
        error=1
      fi
    fi
    shift
  done

  if test $error -eq 1; then echo 1>&2; kill_make; fi
}


# get_arch
get_arch()
{
  arch=`uname -m`
  case "$arch" in
    *86*)        echo x86   ;;
    sun*|sparc)  echo sparc ;;
    *)  error "get_arch: unsupported output from uname -m: $arch" ;;
  esac
}


# get_os
get_os()
{
  os=`uname -s`
  case "$os" in
    Linux|linux)  echo linux    ;;
    SunOS)        echo solaris  ;;
    *)  error "get_arch: unsupported output from uname -s: $os" ;;
  esac
}


# get_comp_defaults
get_comp_defaults()
{
  case "`gcc -v 2>&1 | grep version`" in
    *4.7*)  echo gcc47 ;;
    *4.6*)  echo gcc46 ;;
    *4.4*)  echo gcc44 ;;
    *4.3*)  echo gcc43 ;;
    *4.2*)  echo gcc42 ;;
    *4.1*)  echo gcc41 ;;
    *4.0*)  echo gcc40 ;;
    *3.4*)  echo gcc34 ;;
    *3.3*)  echo gcc33 ;;
    *3.2*)  echo gcc32 ;;
    *2.95*)  echo gcc295 ;;
    *2.96*)  echo gcc296 ;;
    *)
      error "get_comp_defaults: can't determine gcc version"
      ;;
  esac
}

# get_comp_execs $CL_COMP
# Возвращаемое первое слово - исполняемый файл компилятора Си, второе - компилятора Си++
get_comp_execs()
{
  case "$1" in
    gcc*)
      maj=`echo $1 | cut -c 4`
      min=`echo $1 | cut -c 5-`
      ver=$maj.$min
      defc=gcc-$ver
      defcpp=g++-$ver
      ;;
    *)
      error "get_comp_execs: unsupported CL_COMP $1"
      ;;
  esac

  wc=`which $defc`;  wcpp=`which $defcpp`
  if test -n "$wc" -a -n "$wcpp" -a -x "$wc" -a -x "$wcpp"; then
    echo $defc $defcpp
    return 0
  fi

  wc=`which gcc`;  wcpp=`which g++`
  if test -n "$wc" -a -n "$wcpp" -a -x "$wc" -a -x "$wcpp"; then
    if gcc -v 2>&1 | grep version | grep -- "$ver" >/dev/null; then
      if g++ -v 2>&1 | grep version | grep -- "$ver" >/dev/null; then
        echo gcc g++
        return 0
      fi
    fi
  fi

  error "get_comp_execs: can't find $1 compilers." \
        "If you are sure they are present in \$PATH, edit cvslvk script and" \
	"fix get_comp_execs() function."
}

# make_rules
# Создает $CL_DIR/rules.cvslvk и $CL_DIR/wilist*
make_rules()
{
  cd $CL_DIR

  echo "# This file is automatically generated by 'cvslvk make_rules'" > $RULES_CVSLVK_TMP
  for i in */rules.cvslvk; do
    if test -f $i; then
      dir=`dirname $i`
      echo >> $RULES_CVSLVK_TMP
      echo 'ifneq ($(filter '$dir',$(CL_WI_LIST)),)' >> $RULES_CVSLVK_TMP
      echo 'override CL_WI := $(CL_DIR)'/$dir >> $RULES_CVSLVK_TMP
      echo '-include $(CL_DIR)/'$i >> $RULES_CVSLVK_TMP
      echo 'endif' >> $RULES_CVSLVK_TMP
    fi
  done
  mv $RULES_CVSLVK_TMP $RULES_CVSLVK
  choose_chgrp_and_chmod
  $CHGRP $CVSGROUP $RULES_CVSLVK
  $CHMOD 664 $RULES_CVSLVK

  for d in *_*; do if test -d $d; then
    postfix=`echo $d | cut -f2 -d_ | cut -f1-2 -d-`
    echo "$d `cat $d/depend.cvslvk 2>/dev/null | tr '\n' ' '`" >> $WILIST-$postfix.tmp.$$
  fi; done
  for i in $WILIST-*; do
    test "`basename $i`" = "`basename $i .tmp.$$`" -a ! -f $i.tmp && rm -f $i;
  done
  for i in $WILIST-*.tmp.$$; do mv $i `basename $i .tmp.$$`; done
  chmod 644 $WILIST-* 2>/dev/null

  $CHGRP $CVSGROUP $WILIST-* 2>/dev/null
  $CHMOD g+w $WILIST-* 2>/dev/null
}


# process_wi [in_clean] <фиксировать ли компилятор> <какой компилятор> <запросы модулей>
#   возможный нулевой параметр - in_clean если не нужно убивать make по ошибкам
#   первый параметр: yes или unknown
#   второй параметр: gcc* или any
#   возврат: первое слово - comp_param_needed или comp_param_not_needed
#            второе - gcc* или any
#            дальше - список примененных WI
process_wi()
{
  if test $1 = "in_clean"; then in_clean=1; shift; else in_clean=0; fi

  postfix=`get_arch`-`get_os`
  key="$*"
  wilist=$WILIST-$postfix


  needcomp="$1"; comp="$2"; shift; shift
  command="(echo $*; echo quiet $needcomp $comp; cat $wilist 2>/dev/null) | awk -f $CL_DIR/process_wi.awk"
  if eval $command >/dev/null; then
    res=`eval $command`;
# gcc33 and gcc32 are compatable.
# If no compiler is set via CL_COMP, try to use gcc33 if any of those
# is suggested, and revert to gcc32 if gcc33 is not available.
# Same with gcc42 and gcc41 and gcc40 and gcc34 - prefer gcc41 of those
# If particular one is set via CL_COMP, enforce it.
  echo $res | ( read p1 ncomp rest;
                case "$comp-$ncomp" in
		  any-gcc33|any-gcc32)
		    if test -n "`which gcc-3.3`"; then
		      ncomp=gcc33
		    elif test -n "`which gcc-3.2`"; then
		      ncomp=gcc32
		    fi
		    ;;
		  any-gcc4*|any-gcc34)
		    if test -n "`which gcc-4.7`"; then
		      ncomp=gcc47
		    elif test -n "`which gcc-4.6`"; then
		      ncomp=gcc46
		    elif test -n "`which gcc-4.4`"; then
		      ncomp=gcc44
		    elif test -n "`which gcc-4.3`"; then
		      ncomp=gcc43
		    elif test -n "`which gcc-4.1`"; then
		      ncomp=gcc41
		    elif test -n "`which gcc-4.2`"; then
		      ncomp=gcc42
		    elif test -n "`which gcc-4.0`"; then
		      ncomp=gcc40
		    elif test -n "`which gcc-3.4`"; then
		      ncomp=gcc34
		    fi
		    ;;
		  gcc33-gcc32|gcc32-gcc33|gcc4*-gcc4*|gcc34-gcc4*|gcc4*-gcc34)
		    ncomp=$comp
		    ;;
		esac
		echo $p1 $ncomp $rest )
    return
  fi

  if test "$in_clean" = "1"; then
    echo 1>&2
    echo "WARNING:" 1>&2
    eval $command 1>&2
    echo 1>&2
    echo "WI settings will be ignored. Your clean may be incomplete." 1>&2
    echo "(you may run \"make show_wi\" to see complete WI logic)" 1>&2
    echo 1>&2
    if test "$needcomp" = "yes"; then echo $comp; else echo "any"; fi
  else
    echo_build_error
    eval $command 1>&2
    echo 1>&2
    echo "You may run \"make show_wi\" to see complete WI logic" 1>&2
    echo 1>&2
    kill_make
  fi
}

# show_wi <параметры process_wi>
show_wi()
{
  postfix=`get_arch`-`get_os`
  wilist=$WILIST-$postfix
  needcomp="$1"; comp="$2"; shift; shift
  (echo $*; echo verbose $needcomp $comp; cat $wilist 2>/dev/null) | awk -f $CL_DIR/process_wi.awk 1>&2
  kill_make
}


# get_bd_for_clean <вычисленный BD> <значение CL_COMP>
# Используется с целью угадать CL_BD когда не работала логика WI
get_bd_for_clean()
{
  if test -d $1; then echo $1; return; fi

  # Maybe replacing compiler field will help ...
  case "$1" in
    *_*-*-*)
      # module name exists, at least 3 params
      regexp='^\([^_]*_[^-]*-[^-]*-\)\([^-]*\)\(.*\)$'
      ;;
    *-*-*)
      # no module name, at least 3 params
      regexp='^\([^-]*-[^-]*-\)\([^-]*\)\(.*\)$'
      ;;
    *)
      # less than 3 params - we can't help ...
      echo $1
      return
  esac

  for comp in $2 gcc47 gcc46 gcc44 gcc33 gcc32 gcc41 gcc43 gcc42 gcc40 gcc295 gcc296; do
    try=`echo -n $1 | sed s/"$regexp"/'\1'$comp'\3'/`
    if test -d $try; then echo $try; return; fi
  done

  # We can't help more ...
  echo $1
}


# setup_bd <имя каталога сборки>
setup_bd()
{
  mkdir -p $1
  touch $1/CVSLVK_BUILD_DIR
  # Удалить ссылки, показывающие на какие-либо WI
  # Для этого надо выделать X - первый элемент в назначении ссылки и проверить
  # наличие X/CVSLVK_BUILD_DIR
  (echo */CVSLVK_BUILD_DIR; ls -l) | awk '
    BEGIN {m=0}
    m==0 {m=1;
          for (i=1; i<=NF; i++) {
	    split($i,a,"/")
	    if (a[1]!="'$1'")  bd[a[1]]=1
	  }
	  next
	 }
    NF==11 {split($11,a,"/")
            if (bd[a[1]]==1)  print("rm -f " $9)
	   }' | sh
}


# remove_old_symlinks <список CL_SYMLINKS>
# Требуется удалить symlinks, указывающие куда-то в CL_DIR и отсутствующие в списке
remove_old_symlinks()
{
  ( ls -l | grep '^'$CL_DIR;
    echo
    echo $*
  ) | awk '/^$/ {getline;
	         for (i=1; i<=NF; i++) {
		   n=split($i,a,"/")
		   remove[a[n]]=0;
		 }
	         printf("rm -f");
	         for (i in remove) if (remove[i]==1) printf(" "i)
		 exit}
	   {remove[$9]=1}' | sh
}


# cleanall
cleanall()
{
  for i in */CVSLVK_BUILD_DIR; do
    if test -f $i; then
      d=`dirname $i`
      symlinks=`cat $d/SYMLINKS 2>/dev/null`
      echo rm -rf $symlinks $d
      rm -rf $symlinks $d
    fi
  done
}


# complete_wi <полное имя инсталляции>
complete_wi()
{
  scm=""
  branch=$(git name-rev --name-only HEAD 2>/dev/null)
  if [ "$branch" ]; then
    scm="git"
    head=$(git log -1 --pretty=format:%h 2>/dev/null)
    git update-index --refresh -q >/dev/null
    if ! git diff-index --quiet HEAD .;then
      head="+$head"
    fi
  else
    branch=$(svn info 2>/dev/null | sed -n 's/^URL: //p')
    if [ "$branch" ]; then
      scm="svn"
      head=$(LANG=C svnversion -n .| sed 's/^\(.*\)M/+\1/')
    fi
  fi

  cd $CL_DIR
  choose_chgrp_and_chmod
  find $1 -exec $CHGRP $CVSGROUP \{\} \; 2>/dev/null
  find $1 -exec $CHMOD ug+rw \{\} \; 2>/dev/null
  find $1 -perm -100 -exec $CHMOD g+rwx \{\} \; 2>/dev/null
  find $1 -exec chmod a+r \{\} \; 2>/dev/null
  find $1 -perm -100 -exec chmod a+rx \{\} \; 2>/dev/null

  if [ "$scm" ]; then
    echo
    echo "$scm $head $branch" > $1/revision
    printf "scm head branch\n$scm $head $branch\n" | column -t
  fi

  make_rules
}


# remove_wi <полное имя инсталляции> ...
remove_wi()
{
  cd $CL_DIR
  test $# -eq 0 && return 0

  res=0
  for i in $*; do
    if test ! -d $i; then
      echo "No such working installation $i" 1>&2
      res=1
    fi
    if test -f $i/NOREMOVE; then
      echo "$i/NOREMOVE file exists - skipping this WI"
      res=1
    else
      rm -rf $i
    fi
  done

  make_rules
  return $res
}


# liborder <ограничения> -- <библиотеки>
liborder()
{
  cons=""
  while test "x$1" != "x--"; do
    if test "x$cons" = "x"; then cons="$1"; else cons="$cons $1"; fi
    shift
  done
  shift
  libs="$*"
  if printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk >/dev/null; then
    printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk
    return 0
  else
    echo_build_error
    printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk 1>&2
    echo 1>&2
    kill_make
  fi
}


# touchap <CL_BD> [файл параметры] -- ...
touchap()
{
  CL_BD=$1; shift;
  while test "x$1" != "x"; do
    file=$CL_BD/$1; shift
    params="";
    while test "x$1" != "x--" -a "x$1" != "x"; do params="$params $1"; shift; done
    test "x$1" = "x--" && shift
    if test ! -f $file; then
      printf "%s" "$params" > $file
    else
      test "x$params" = "x`cat $file`" || printf "%s" "$params" > $file
    fi
  done
}


# install [каталог] - инсталляция из указанного или из текущего каталога
install()
{
  test x"$1" != x && cd $1
  choose_chgrp_and_chmod
 # Создание скрипта process_wi.awk
  (
    echo "# This file is automatically generated during cvslvk installation"
    echo "# Please use the source to view or edit"
    cpp -P process_wi.awk.in | tr '@' '\n' | awk '{if(NF>0)print}'
  ) > process_wi.awk
 # Собственно установка
  (cd $CL_DIR && rm -f *.awk Makefile.cvslvk cvslvk autobuild.conf)
  cp Makefile.cvslvk cvslvk getppid.awk process_wi.awk liborder.awk cppargs.awk autobuild.conf $CL_DIR/
  rm -f process_wi.awk
 # Удаление устаревших псевдомодулей
  for i in $CL_DIR/*/REMOVE_ON_CVSLVK_UPDATE; do
    test -f $i && rm -rf `dirname $i`
  done
 # Установка/обновление псевдомодулей
  test -f ./pseudo/install && (cd ./pseudo&&./install)
 # Установка прав
  cd $CL_DIR
  $CHGRP $CVSGROUP * 2>/dev/null
  $CHMOD ug+w * 2>/dev/null
 # Окончание установки
  make_rules
}


# autobuild <метка>
# Параметры CL_MODULE=... и CL_OPTIMIZE=1 добавляются автоматически
build()
{
  if test $# -ne 1; then
    echo 1>&2
    echo '"cvslvk build" requires single parameter, which is the label of the' 1>&2
    echo 'requested builds. Type "cvslvk show_ab" to see available builds.' 1>&2
    echo 1>&2
    return 1
  fi

  FOUND=0
  eval `cat $AUTOBUILD_CONF | grep -v '^#' | awk -F: '{if ($1=="'$1'") {printf("FOUND=1;WI="$2";MODULE="$3";TAG="$4";PARAMS=\""$5"\";DEPS="$6";COMMENT=\""$7"\";")} }'`
  if test $FOUND -ne 1; then
    echo 1>&2
    echo 'Build "'$1'" is not available.' 1>&2
    echo 'Type "cvslvk show_ab" to see available builds.'
    echo 1>&2
    return 1
  fi

  WINAME=`echo $WI | cut -d_ -f1`
  WIPARAMS=`echo $WI | cut -d_ -f2`
  if echo $WI | grep _ >/dev/null; then
    FULL_WI_NAME=$WINAME'_'`get_arch`'-'`get_os`'-'$WIPARAMS'-optimized'
  else
    FULL_WI_NAME=$WINAME'_'`get_arch`'-'`get_os`'-optimized'
  fi

  if test -d $CL_DIR/$FULL_WI_NAME; then
    echo
    echo "Working installation $FULL_WI_NAME already exists."
    echo "Most likely you will not want to touch it."
    echo "If you really want to rebuild it, please remove it first."
    echo
    return 0
  fi

  if test "$DEPS" != ""; then
    for d in `echo $DEPS | tr ',' ' '`; do
      echo
      echo "Building dependency $d ..."
      echo
      $CL_DIR/cvslvk build $d #Вызываем новую копию скрипта, чтобы не портить переменные
      if test $? -ne 0; then
        echo 1>&2
	echo "Dependency $d build failed. Can't build $1" 1>&2
        echo 1>&2
	return 1
      fi
    done
  fi

  mkdir -p $CL_DIR/tmp/$LOGNAME
  choose_chgrp_and_chmod
  $CHGRP $CVSGROUP $CL_DIR/tmp 2>/dev/null
  $CHMOD 775 $CL_DIR/tmp 2>/dev/null
  cd $CL_DIR/tmp/$LOGNAME

  TAGINFO="without tag"
  test x"$TAG" != x && TAG_FLAG="-r $TAG" && TAGINFO="with tag $TAG"
  echo
  echo "Checking out CVS module $MODULE $TAGINFO ..."
  echo
  cvs checkout $TAG_FLAG $MODULE
  if test $? -ne 0 -o ! -d $MODULE; then
    echo
    echo "CVS checkout failed."
    echo "Make sure that you have set CVSROOT correctly, done 'cvs login'"
    echo "and have appropriate permissions."
    echo
    rm -rf $CL_DIR/tmp/$LOGNAME/$MODULE
    return 1
  fi

  cd $MODULE
  MAKE_PARAMS="CL_MODULE=$WINAME CL_OPTIMIZE=1 $PARAMS"
  echo
  echo "Running make update_wi $MAKE_PARAMS ..."
  echo
  make update_wi $MAKE_PARAMS
  if test $? -ne 0; then
    echo
    echo "Command failed. Please report to the module maintainer[s]."
    echo
    cd ..
    rm -rf $CL_DIR/tmp/$LOGNAME/$MODULE
    return 1
  fi
  cd ..

  echo
  echo "Cleaning up ..."
  echo
  rm -rf $CL_DIR/tmp/$LOGNAME/$MODULE
  echo "Build complete."
  echo
  return 0
}


# show_ab
show_ab()
{
  echo
  cat $AUTOBUILD_CONF | grep -v '^#' | awk -F: '{if($1!="")print($1 ": "$7)}'
  echo
}


# compile [nowall] <source> <target> <compiler> <options>
# Одновременно вычисляются зависимости; пишется файл <target>.deps.
# Если установлена переменная CL_VERBOSE, то выдаются полная командная строка
# компиляции, иначе - только строка "Compiling <source> ..."
compile()
{
  source="$1"; target="$2"; comp="$3"; shift 3
  if test "$1" = "nowall"; then
    shift
    options="`echo $* | sed s/-Wall//g`"
  else
    options="$*"
  fi
  dep="$target.deps"
  if test "" = "$CL_VERBOSE"; then
    locale 2>/dev/null | awk -F '(=|")+' '
      $1=="LC_MESSAGES" && $2=="ru_RU.KOI8-R" {
        print("Компилируется '"$source"' при помощи '"$comp"' ...")
        f=1
      }
      END { if (f!=1) print("Compiling '"$source"' using '"$comp"' ...") }'
  else
    echo "$comp $options -o $target $source"
  fi
  $comp $options -MMD -MF "$dep.tmp" -o "$target" "$source" || return 1
  tr '\n' ' ' < $dep.tmp | sed 's/[^ ]*://g; s/[\\]//g; s/$/:/' > $dep.tmp2
  echo >> $dep.tmp
  cat $dep.tmp2 >> $dep.tmp
  echo >> $dep.tmp
  rm -f $dep.tmp2
  if diff $dep $dep.tmp >/dev/null 2>&1; then
    rm -f $dep.tmp
  else
    rm -f $dep
    mv $dep.tmp $dep
  fi
  return 0
}

# link <target> command
# Команда должна быть указана посностью (в т.ч. с повторением target)
# Данная функция используется только для выдачи
link()
{
  target="$1"; shift
  if test "" = "$CL_VERBOSE"; then
    locale 2>/dev/null | awk -F '(=|")+' '
      $1=="LC_MESSAGES" && $2=="ru_RU.KOI8-R" {
        print("Собирается '"$target"' ...")
        f=1
      }
      END { if (f!=1) print("Linking '"$target"' ...") }'
  else
    echo "$*"
  fi
  $*
}

command=$1
if test "$command" = ""; then
  echo "cvslvk: usage: cvslvk command [parameters]"
  exit 1
fi
shift

case "$command" in
  check_vars|error|get_arch|get_os|make_rules|setup_bd|remove_old_symlinks|\
  cleanall|process_wi|show_wi|get_bd_for_clean|liborder|touchap|\
  complete_wi|remove_wi|\
  install|build|show_ab|compile|link|get_comp_defaults|get_comp_execs)
    $command $*
    exit $?
    ;;
  *)
    echo "cvslvk: unknown command: $command" 1>&2
    exit 1
    ;;
esac
