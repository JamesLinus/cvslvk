#!/bin/sh
# Вспомогательный скрипт для работы с CVS в ЛВК

if test "$CL_DIR" = ""; then
  echo 'CL_DIR is not set' 1>&2
  exit 1
fi

# Файл, создаваемый по cvslvk make_rules
RULES_CVSLVK=$CL_DIR/rules.cvslvk
RULES_CVSLVK_TMP=$CL_DIR/rules.cvslvk.tmp  # Временная копия того же файла

# Группа пользователей CVS
CVSGROUP=cvsusers

# Полные имена следующих двух файлов получаются добавлением к ним -<arch>-<os>
# Префикс файла со списком рабочих инсталляций и их требований
WILIST=$CL_DIR/wilist
# Префикс файла кеширования запросов к process_wi
PROCESSWICACHE=$CL_DIR/wicache

MYPID=$$
kill_make()
{
  MAKEPID=`(echo $MYPID; ps -l) | awk -f $CL_DIR/getppid.awk`
  kill $MAKEPID;
  exit 1;
}


choose_chgrp_and_chmod()
{
  clgroup=`ls -Lld $CL_DIR | awk '{print($4)}'`
  if test "$clgroup" = "$CVSGROUP"; then
    CHGRP=chgrp
    CHMOD=chmod
  else
    CHGRP=true
    CHMOD=true
  fi
}


echo_build_error()
{
      echo 1>&2
      echo "*** ERROR ***" 1>&2
      echo 1>&2
}


# error сообщение
error()
{
  echo_build_error
  echo $* 1>&2
  echo 1>&2
  kill_make
}


# check_vars ИМЯ=значение [значение1 ...] -- ...
check_vars()
{
  error=0
  while test "" != "$1"; do
    var=`echo $1 | cut -f1 -d=`
    value=`echo $1 | cut -f2 -d=`
    shift
    if test "--" = "$1"; then
      if test "" = "$value"; then
        if test $error -eq 0; then echo_build_error; fi
        echo "Variable '$var' is not set." 1>&2
        error=1
      fi
    else
      found=0
      alts=""
      while test "--" != "$1"; do
        alts="$alts $1"
        if test "$value" = "$1"; then found=1; fi
	shift
      done
      if test $found -eq 0; then
        if test $error -eq 0; then echo_build_error; fi
        echo "Bad value '$value' of variable '$var' (supported values:$alts)." 1>&2
        error=1
      fi
    fi
    shift
  done

  if test $error -eq 1; then echo 1>&2; kill_make; fi
}


# get_arch
get_arch()
{
  arch=`uname -m`
  case "$arch" in
    *86*)        echo x86   ;;
    sun*|sparc)  echo sparc ;;
    *)  error "get_arch: unsupported output from uname -m: $arch" ;;
  esac
}


# get_os
get_os()
{
  os=`uname -s`
  case "$os" in
    Linux|linux)  echo linux    ;;
    SunOS)        echo solaris  ;;
    *)  error "get_arch: unsupported output from uname -s: $os" ;;
  esac
}


# make_rules
# Создает $CL_DIR/rules.cvslvk и $CL_DIR/wilist*
make_rules()
{
  cd $CL_DIR

  echo "# This file is automatically generated by 'cvslvk make_rules'" > $RULES_CVSLVK_TMP
  for i in */rules.cvslvk; do
    if test -f $i; then
      dir=`dirname $i`
      echo >> $RULES_CVSLVK_TMP
      echo 'ifneq ($(filter '$dir',$(CL_WI_LIST)),)' >> $RULES_CVSLVK_TMP
      echo 'override CL_WI = $(CL_DIR)'/$dir >> $RULES_CVSLVK_TMP
      echo '-include $(CL_DIR)/'$i >> $RULES_CVSLVK_TMP
      echo 'endif' >> $RULES_CVSLVK_TMP
    fi
  done
  mv $RULES_CVSLVK_TMP $RULES_CVSLVK
  choose_chgrp_and_chmod
  $CHGRP $CVSGROUP $RULES_CVSLVK
  $CHMOD 664 $RULES_CVSLVK

  rm -f $WILIST-* $PROCESSWICACHE-*
  for d in *_*; do if test -d $d; then
    postfix=`echo $d | cut -f2 -d_ | cut -f1-2 -d-`
    echo "$d `cat $d/depend.cvslvk 2>/dev/null | tr '\n' ' '`" >>  $WILIST-$postfix
  fi; done
  chmod 644 $WILIST-* 2>/dev/null

  for i in $WILIST-*; do
    cache=$PROCESSWICACHE-`basename $i | cut -f 2- -d-`
    touch $cache
    chmod 666 $cache
  done

  $CHGRP $CVSGROUP $WILIST-* $PROCESSWICACHE-* 2>/dev/null
  $CHMOD g+w $WILIST-* 2>/dev/null
}


# process_wi [in_clean] <фиксировать ли компилятор> <какой компилятор> <запросы модулей>
#   возможный нулевой параметр - in_clean если не нужно убивать make по ошибкам
#   первый параметр: yes или unknown
#   второй параметр: gcc, suncc или any
#   возврат: первое слово - _suncc_, _gcc_ или _any_
#            дальше - список примененных WI
process_wi()
{
  if test $1 = "in_clean"; then in_clean=1; shift; else in_clean=0; fi

  postfix=`get_arch`-`get_os`
  key="$*"
  cache=$PROCESSWICACHE-$postfix
  wilist=$WILIST-$postfix

  res=`awk -F: '{if($1=="'"$key"'") print($2)}' $cache 2>/dev/null`
  if test "$res" != ""; then echo $res; return; fi

  needcomp="$1"; comp="$2"; shift; shift
  command="(echo $*; echo quiet $needcomp $comp; cat $wilist 2>/dev/null) | awk -f $CL_DIR/process_wi.awk"
  if eval $command >/dev/null; then
    res=`eval $command`;
    echo "$key:$res" >> $cache 2>/dev/null
    choose_chgrp_and_chmod
    $CHGRP $CVSGROUP $cache 2>/dev/null
    $CHMOD 666 $cache 2>/dev/null
    echo $res
    return
  fi

  if test "$in_clean" = "1"; then
    echo 1>&2
    echo "WARNING:" 1>&2
    eval $command 1>&2
    echo 1>&2
    echo "WI settings will be ignored. Your clean may be incomplete." 1>&2
    echo "(you may run \"make show_wi\" to see complete WI logic)" 1>&2
    echo 1>&2
    if test "$needcomp" = "yes"; then echo $comp; else echo "any"; fi
  else
    echo_build_error
    eval $command 1>&2
    echo 1>&2
    echo "You may run \"make show_wi\" to see complete WI logic" 1>&2
    echo 1>&2
    kill_make
  fi
}

# show_wi <параметры process_wi>
show_wi()
{
  postfix=`get_arch`-`get_os`
  wilist=$WILIST-$postfix
  needcomp="$1"; comp="$2"; shift; shift
  (echo $*; echo verbose $needcomp $comp; cat $wilist 2>/dev/null) | awk -f $CL_DIR/process_wi.awk 1>&2
  kill_make
}


# get_bd_for_clean <вычисленный BD> <значение CL_COMP>
# Используется с целью угадать CL_BD когда не работала логика WI
get_bd_for_clean()
{
  if test -d $1; then echo $1; return; fi

  part3=`echo $1 | sed 's/[^-]*-[^-]*-\([^-]*\).*/\1/'`
  if test "$part3" = "gcc" -o "$part3" = "suncc"; then
    echo $1; return
  fi

  echo $1 | sed 's/\([^-]*-[^-]*\)\(.*\)/\1-'$2'\2/'; return
}


# depend <имя входного файла> <имя выходного файла> <параметры для cpp>
depend()
{
  cpp=cpp
  file=$1;  dep=$2;  shift 2

  echo "Calculating dependences for $file ..."

  bd=`dirname $dep`
  if test `basename $file .c`.c = `basename $file`; then
    flags="$* `cat $bd/SYS_MKDEP_FLAGS_C 2>/dev/null`"
  else
    flags="$* `cat $bd/SYS_MKDEP_FLAGS_CXX 2>/dev/null`"
  fi

  $cpp -MM $flags $file > $dep.tmp
  if test $? -ne 0; then
    printf $dep': $(ALWAYS)\n\n' > $dep
    rm -f $dep.tmp;
    return 1;
  fi
  (
    printf "`dirname $dep`/"; sed 's/.mm.o:/.o:/' $dep.tmp
    echo
    sed 's@.*:\(.*\)@'$dep':\1@' $dep.tmp
    echo
    sed 's/.*:[ ]*\(.*\)/\1/'  $dep.tmp | tr '\n' ' ' | tr -d '\\'; echo ":"; echo
  ) > $dep
  rm -f $dep.tmp
  return 0
}


# remove_other_bd_links <имя каталога сборки>
remove_other_bd_links()
{
  ls -l | awk '{ if (NF==11) {
		   if ( split ( $11,a,"/" ) == 2 ) {
		     if ( (a[1] != "'$1'") && (a[2] == $9) ) {
		       print ( "rm -f " $9 );
		       }
		     }
		   }
		}' | sh
}


# cleanall
cleanall()
{
  for i in */CVSLVK_BUILD_DIR; do
    if test -f $i; then
      d=`dirname $i`
      symlinks=`cat $d/SYMLINKS 2>/dev/null`
      echo rm -rf $symlinks $d
      rm -rf $symlinks $d
    fi
  done
}


# make_sys_mkdep_flags_c <CL_BD> <gcc>|<suncc> <SYS_CFLAGS>
make_sys_mkdep_flags_c()
{
  bd=$1; comp=$2; shift 2
  cd $bd
  if test "x$comp" != "xgcc"; then
    touch SYS_MKDEP_FLAGS_C
  else
    echo > cvslvk-test.c
    gcc -v -E $* cvslvk-test.c 2>&1 | grep /cpp | tr ' ' '\n' |\
      egrep -v "/cpp|^cvslvk-test.c|^-v|^-lang" |\
      tr '\n' ' ' > SYS_MKDEP_FLAGS_C
    rm -f cvslvk-test.c
  fi
  return 0
}


# make_sys_mkdep_flags_cxx <CL_BD> <gcc>|<suncc> <SYS_CXXFLAGS>
make_sys_mkdep_flags_cxx()
{
  bd=$1; comp=$2; shift 2
  cd $bd
  if test "x$comp" != "xgcc"; then
    touch SYS_MKDEP_FLAGS_CXX
  else
    echo > cvslvk-test.cpp
    g++ -v -E $* cvslvk-test.cpp 2>&1 | grep /cpp | tr ' ' '\n' |\
      egrep -v "/cpp|^cvslvk-test.cpp|^-v|^-lang" |\
      tr '\n' ' ' > SYS_MKDEP_FLAGS_CXX
    rm -f cvslvk-test.cpp
  fi
  return 0
}


# before_create_wi <полное имя инсталляции>
# Вызывается по make create_wi перед вызовом make all
before_create_wi()
{
  cd $CL_DIR
  if test -d $1; then
    echo_build_error
    echo "The working installation $1 already exists" 1>&2
    echo "If you wish, you may remove in by running" 1>&2
    echo "  cvslvk remove_wi $1" 1>&2
    echo 1>&2
    return 1
  fi

  mkdir $1
  if test $? -ne 0; then
    echo_build_error
    echo "Failed to create directory $CL_DIR/$1" 1>&2
    echo "Are you sure you are in cvsusers group ?" 1>&2
    echo 1>&2
    return 1
  fi
  rmdir $1
  return 0
}


# before_install_wi <полное имя инсталляции>
# Вызывается по make create_wi перед вызовом make all
before_install_wi()
{
  cd $CL_DIR
  mkdir $1
}


# complete_wi <полное имя инсталляции>
complete_wi()
{
  cd $CL_DIR
  choose_chgrp_and_chmod
  find $1 -exec $CHGRP $CVSGROUP \{\} \;
  find $1 -exec $CHMOD ug+rw \{\} \;
  find $1 -perm -100 -exec $CHMOD g+rwx \{\} \;
  find $1 -exec chmod a+r \{\} \;
  find $1 -perm -100 -exec chmod a+rx \{\} \;

  make_rules
}


# remove_wi <полное имя инсталляции> ...
remove_wi()
{
  cd $CL_DIR
  test $# -eq 0 && return 0

  res=0
  for i in $*; do
    if test ! -d $i; then
      echo "No such working installation $i" 1>&2
      res=1
    fi
    if test -f $i/NOREMOVE; then
      echo "$i/NOREMOVE file exists - skipping this WI"
      res=1
    else
      rm -rf $i
    fi
  done

  make_rules
  return $res
}


# liborder <ограничения> -- <библиотеки>
liborder()
{
  cons=""
  while test "x$1" != "x--"; do
    if test "x$cons" = "x"; then cons="$1"; else cons="$cons $1"; fi
    shift
  done
  shift
  libs="$*"
  if printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk >/dev/null; then
    printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk
    return 0
  else
    echo_build_error
    printf "%s\n%s\n" "$cons" "$libs" | awk -f $CL_DIR/liborder.awk 1>&2
    echo 1>&2
    kill_make
  fi
}


# touchap <CL_BD> [файл параметры] -- ...
touchap()
{
  CL_BD=$1; shift;
  while test "x$1" != "x"; do
    file=$CL_BD/$1; shift
    params="";
    while test "x$1" != "x--" -a "x$1" != "x"; do params="$params $1"; shift; done
    test "x$1" = "x--" && shift
    if test ! -f $file; then
      printf "%s" "$params" > $file
    else
      test "x$params" = "x`cat $file`" || printf "%s" "$params" > $file
    fi
  done
}


selfupdate()
{
  mkdir -p $CL_DIR/tmp/$USER
  choose_chgrp_and_chmod
  $CHGRP $CVSGROUP $CL_DIR/tmp 2>/dev/null
  $CHMOD 775 $CL_DIR/tmp 2>/dev/null
  cd $CL_DIR/tmp/$USER
  cvs checkout cvslvk > /dev/null
  if test $? -ne 0; then rm -rf cvslvk; return 1; fi
  cd cvslvk
  (
    echo "# This file is automatically generated during 'cvslvk selfupdate'"
    echo "# Please use the source to view or edit"
    cpp -P process_wi.awk.in | tr '@' '\n' | awk '{if(NF>0)print}'
  ) > process_wi.awk
  rm -f $CL_DIR/*.awk $CL_DIR/Makefile.cvslvk $CL_DIR/cvslvk
  cp Makefile.cvslvk cvslvk getppid.awk process_wi.awk liborder.awk $CL_DIR/
  cat foreign_modules | ( while read type name; do
    case "$type" in
      use_system)
        dir=$CL_DIR/$name'_'`get_arch`-`get_os`
        mkdir -p $dir 2>/dev/null
	chmod 755 $dir 2>/dev/null
	cp rules.cvslvk.$name $dir/rules.cvslvk 2>/dev/null
	cp depend.cvslvk.$name $dir/depend.cvslvk 2>/dev/null
	chmod 644 $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
        $CHGRP $CVSGROUP $dir $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
        $CHMOD g+w $dir $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
      ;;
      use_wi)
        for dir in $CL_DIR/$name'_'`get_arch`-`get_os`*; do
          if test ! -d $dir; then
	    echo "Warning: hand-made working installation for $name is not present"
	  else
	    touch $dir/NOREMOVE 2>/dev/null
	    cp rules.cvslvk.$name $dir/rules.cvslvk 2>/dev/null
	    cp depend.cvslvk.$name $dir/rules.cvslvk 2>/dev/null
	    chmod 644 $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
            $CHGRP $CVSGROUP $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
            $CHMOD g+w $dir/rules.cvslvk $dir/depend.cvslvk 2>/dev/null
	  fi
	done
      ;;
    esac
    done )
  cd $CL_DIR
  $CHGRP $CVSGROUP * 2>/dev/null
  $CHMOD ug+w * 2>/dev/null
  rm -r $CL_DIR/tmp/$USER/cvslvk
  make_rules
}


command=$1
if test "$command" = ""; then
  echo "cvslvk: usage: cvslvk command [parameters]"
  exit 1
fi
shift

case "$command" in
  check_vars|error|get_arch|get_os|make_rules|remove_other_bd_links|cleanall|\
  make_sys_mkdep_flags_c|make_sys_mkdep_flags_cxx|\
  process_wi|show_wi|get_bd_for_clean|depend|liborder|touchap|\
  before_create_wi|before_install_wi|complete_wi|remove_wi|\
  selfupdate)
    $command $*
    exit $?
    ;;
  *)
    echo "cvslvk: unknown command: $command" 1>&2
    exit 1
    ;;
esac
